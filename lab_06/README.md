# Лабораторная работа #6

## Условие задачи

Построить ДДП, сбалансированное двоичное дерево и хеш-таблицу по
указанным данным. Сравнить эффективность поиска в сбалансированном двоичном дереве, в ДДП и в хеш-таблице, используя закрытую адресацию. Вывести на экран деревья и хеш-таблицу. Подсчитать среднее количество сравнений для поиска данных в указанных структурах. Произвести реструктуризацию хеш-таблицы, если среднее количество сравнений больше указанного. Оценить эффективность использования этих структур (по времени и памяти) для поставленной задачи.

## Описание ТЗ

В текстовом файле содержатся целые числа. Построить ДДП из чисел файла. Вывести его на экран в виде дерева. Сбалансировать полученное дерево и вывести его на экран. Построить хеш-таблицу из чисел файла. Использовать закрытое хеширование для устранения коллизий. Осуществить удаление введенного целого числа в ДДП, в сбалансированном дереве, в хеш-таблице и в файле. Сравнить время удаления, объем памяти и количество сравнений при использовании различных (4-х) структур данных. Если количество сравнений в хеш-таблице больше указанного, то произвести реструктуризацию таблицы, выбрав другую функцию.

### Исходные данные

Для построения исходных структур данных целые числа хранятся в файле.

### Результаты

Результатом является выведенная в окно терминала ДДП, сбалансированное дерево, хеш-таблица, текущее состояние файла и время удаления элемента в каждой из этих структур.

### Способ обращения к программе

Обращение к программе происходит через исполняемый файл. Исходные данные вводятся в файл, вывод результатов производится в окно терминала.

### Аварийные ситуации и ошибки пользователя

* Некорректный ввод.
* Пустой ввод.
* Просмотр пустой структуры
* Удаление несуществующего элемента

Во всех перечисленных случаях программа выдаёт сообщение об ошибке.

## Описание СД

Двоичное дерево поиска

```
typedef struct node_bst node;
struct node_bst{    type data;			// Вершина    node *left;			// Левая ветвь    node *right;			// Правая ветвь};
```

Сбалансированное дерево

```
typedef struct node_avl node_avl;
struct node_avl{    type data;			// Вершина    node_avl *left;		// Левая ветвь    node_avl *right;	// Правая ветвь    int height;			// Высота};
```

Хеш-таблица

```
typedef struct node_ht node_ht;
struct node_ht{    int data;			// Значение    int key;			// Ключ};
```

## Тесты

**Удаление несуществующего элемента**

||ДДП|АВЛ дерево|ХТ|Файл|
|:-:|:-:|:-:|:-:|:-:|
|Время|4320|1131|648|237|
|Количество сравнений|7|4|0|14|
|Память|240|288|800|400|

**Удаление существующего элемента**

||ДДП|АВЛ дерево|ХТ|Файл|
|:-:|:-:|:-:|:-:|:-:|
|Время|8685|3009|750|17685|
|Количество сравнений|9|2|1|2|
|Память|220|264|800|400|

## Выводы

В ходе данной лабораторной работы были реализованы основные операции над деревьями: обход деревьев, включение, исключение и поиск узлов; построены и обработаны хеш-таблицы, получено сравнение эффективности удаления в сбалансированных деревьях, в двоичных деревьях поиска, в хеш-таблицах и в файле.

Скорость обработки хеш-таблиц зависит от количества коллизий. Если таковые отсутствуют, то эта структура данных обрабатывается наиболее быстро (поиск - O(1)). При увеличении числа коллизий эффективность уменьшается, при 3-4 и больше хеш-таблица нуждается в рестуктуризации, т.к. эффективность использования такой структуры данных отсутствует. Скорость обработки АВЛ дерева зависит от необходимости реструктуризовывать дерево при его балансировки (поиск - O(log2n)). В целом, АВЛ дерево обрабатывется быстрее чем ДДП, которое может вырождаться в линейный список (поиск может достигать (O(n)). По памяти ДДП и АВЛ дают преимущество, если заранее не известно количество используемых элементов.

## Вопросы

**1. Что такое дерево?**

Дерево – это нелинейная структура данных, используемая для представления иерархических связей, имеющих отношение «один ко многим».

**2. Как выделяется память под представление деревьев?**

В памяти деревья можно представить в виде связей с предками (массив, связывающий данную вершину и ту вершину, из которой она идёт) или связного списка потомков (структура данных, каждый элемент которой указывает на вершину, идущую из данной).

**3. Какие стандартные операции возможны над деревьями? 4. Что такое дерево двоичного поиска?**

Основные операции с деревьями: обход дерева, поиск по дереву, включение в дерево, исключение из дерева.

Дерево двоичного поиска – это такое дерево, в котором все левые потомки моложе предка, а все правые – старше. Это свойство называется характеристическим свойством дерева двоичного поиска и выполняется для любого узла, включая корень.

**5. Чем отличается идеально сбалансированное дерево от АВЛ дерева?**

Сбалансированное дерево - это дерево, при построении которого число вершин в левом и правом поддеревьях отличается не более чем на единицу.

АВЛ-дерево - это двоичное дерево, у которого высота каждого узла дерева двух поддеревьев отличается не более чем на единицу.

**6. Чем отличается поиск в АВЛ-дереве от поиска в дереве двоичного поиска?**

Сложность поиска в АВЛ-дереве сотставляет O(log2n), в ДДП может доходить до O(n). Т.к. ДДП может вырождаться в линейный список, время его обработки может значительно увеличиться, данный недостаток
у АВЛ-дерева отсутсвует.

**7. Что такое хеш-таблица, каков принцип ее построения?**

Хеш-таблица - это массив, заполненный в порядке, определенным хеш-функцией.

**8. Что такое коллизии? Каковы методы их устранения.**

Коллизия - это ситуация, при которой разным ключам соответствует одно значение хеш-функции.

Первый метод устранения коллизий – это внешнее (открытое) хеширование (метод цепочек). В случае, когда элемент таблицы с индексом, который вернула хеш-функция, уже занят, к нему присоединяется связный список, который содержит все значения.

Другой путь решения проблемы, связанной с коллизиями – внутреннее (закрытое) хеширование (открытая адресация). В случае, если ячейка с вычисленным индексом занята, то можно просто просматривать следующие записи таблицы по порядку, до тех пор, пока не будет найден ключ K или пустая позиция в таблице.

**9. В каком случае поиск в хеш-таблицах становится неэффективен?**

При любом методе разрешения коллизий необходимо ограничить длину поиска элемента. Если для поиска элемента необходимо более 3–4 сравнений, то эффективность использования такой хеш-таблицы пропадает и ее следует реструктуризировать, чтобы минимизировать количество сравнений для поиска элемента.

**10. Эффективность поиска в АВЛ деревьях, в дереве двоичного поиска и в хеш-таблицах.**

Сложность поиска в АВЛ дереве сотставляет O(log2n), в ДДП может доходить до O(n) (при вырождении в линейный список), в хеш-таблице - O(1) (при отсутствии коллизий).